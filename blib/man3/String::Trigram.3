.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Trigram 3"
.TH Trigram 3 "2008-07-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Trigram \- Find similar strings by trigram (or 1, 2, 4, etc.\-gram) method
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use String::Trigram;
.Ve
.SS "Object Oriented Interface"
.IX Subsection "Object Oriented Interface"
.Vb 1
\&  my @cmpBase = qw(establishment establish establishes established disestablish disestablishmentarianism);
\&
\&  my $trig = new String::Trigram(cmpBase => \e@cmpBase);
\&
\&  my $numOfSimStrings = $trig\->getSimilarStrings("establishing", \e%result);
\&
\&  print "Found $numOfSimStrings similar strings.\en";
\&
\&  foreach (keys %result) {
\&    print "Similar string $_ has a similarity of ", sprintf ("%02f", ($result{$_} * 100)), "%\en";
\&  }
.Ve
.SS "Functional Interface"
.IX Subsection "Functional Interface"
.Vb 2
\&  my $string1 = "foo";
\&  my $string2 = "boo";
\&
\&  my $smlty = String::Trigram::compare($string1, $string2);
\&
\&  print "$string1 and $string2 have a similarity of ", sprintf("%.2f", ($smlty * 100)), "%.\en";
\&
\&  $smlty = String::Trigram::compare($string1, $string2);
\&
\&  print "$string1 and $string2 have a similarity of ", sprintf("%.2f", ($smlty * 100)), "%.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module computes the similarity of two strings based on the
trigram method. This consists of splitting some string into triples of
characters and comparing those to the trigrams of some other
string. For example the string kangaroo has the trigrams \f(CW\*(C`{kan ang
nga gar aro roo}\*(C'\fR. A wrongly typed kanagaroo has the trigrams \f(CW\*(C`{kan
ana nag aga gar aro roo}\*(C'\fR. To compute the similarity we 
divide the number of matching trigrams (tokens not types) by the
number of all trigrams (types not tokens). For our example this means
dividing 4 / 9 resulting in 0.44.
.PP
To balance the disadvantage of the outer characters (every one of
which occurs in only one trigram \- while the second and the
penultimate occur in two and the rest of the characters in three
trigrams each) somewhat we pad the string with blanks on either
side resulting in two more trigrams \f(CW\*(Aq ka\*(Aq\fR and \f(CW\*(Aqro \*(Aq\fR, when using a padding of one blank.  Thus we
arrive at 6 matching trigrams and 11 trigrams all in all, resulting in
a similarity value of 0.55.
.PP
When using the trigram method there is one thing that might appear as a
problem: Two short strings with one (or two or three ...) different
trigrams tend to produce a lower similarity then two long ones. To counteract this
effect, you can set the module's \f(CW\*(C`warp\*(C'\fR property. If you set it to
something greater than 1.0 (try something between 1.0 and 3.0, flying
at warp 9 won't get you anywhere here), this will lift the similarity
of short strings more and the similarity of long strings less,
resulting in the '%%%' curve in the (schematical) diagram below.
.PP
.Vb 10
\&        1.0
\&  simi\-  |                                   %            *      %
\&  larity |             %           *                   #         #
\&  value  |      %         *          #
\&         |            *     #
\&         |    %    *    #
\&         |       *   #
\&         |      *
\&         |   % * #
\&         |
\&         |   *
\&         |  % #
\&         |  *
\&         |                         ***  no warp (i.e. warp == 1.0)
\&         | %#                      %%%                    warp > 1
\&         | *                       ###                    warp < 1
\&         |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&        0.0
\&                                                  length of string
\&
\&       Dependency of similarity value on length of string and warp
.Ve
.PP
Don't hesitate to use this feature, it sometimes really helps
generating useful results where you otherwise wouldn't have got any.
.PP
Please be aware of that a \f(CW\*(C`warp\*(C'\fR less than 1.0 will result in an inverse
effect pulling down the similarity of short strings a lot and the
similarity of long ones less, resulting in the '###' curve. I have no
idea what this can be good for, but it's just a side effect of the
method. How is all this done? Take a look at the code.
.PP
Splitting strings into trigrams is a time consuming affair and if you
want to compare a set of n strings to another set of m strings and you
do it on a member to member base you will have to do n * m
splittings. To avoid this, this module takes a set of strings as the
base of comparison and generates an index of every trigram occuring in
any of the members of the set (including the information, how often
the trigram occurs in a given member string). Then you can feed it the
members of the other set one by one. This results in an amount of n +
m splitting plus the overhead from generating the index. This way we
save a lot of time at the expense of memory, so \- if you operate on a
great amount of strings \- this might turn out to be somewhat of a
problem. But there you are. There's no such thing as a free lunch.
.PP
Anyway \- the module is optimized for comparisons of sets of string
which results in single comparisons being slower than it might
be. So, if you use the \f(CW\*(C`compare()\*(C'\fR function which compares single
strings in a functional interface, to be able to use the full
functionality of the module and not to get into the need to program
same things twice, internally a String::Trigram object is instantiated
and an index of the trigrams of one of the strings is generated. In
practice however this shouldn't be a big disadvantage since a single
comparison or just a few won't need too much (absolute) time.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my @base = qw(chimpanzee lion emu kangaroo);
\&
\&  my $trig = new String::Trigram(cmpBase => \e@base);
.Ve
.PP
This is the constructor. Before we are able to do any computing of
similarities, it will want the parameter \f(CW\*(C`cmpBase\*(C'\fR to point to a
reference to an array of strings (the base of comparison). Everything
else is taken care of unless you want to change the defaults:
.PP
.Vb 7
\&  my $trig = new String::Trigram(cmpBase        => \e@base,
\&                                 minSim         => 0.5,
\&                                 warp           => 1.6,
\&                                 ignoreCase     => 0,
\&                                 keepOnlyAlNums => 1,
\&                                 ngram          => 5,
\&                                 debug          => 1);
.Ve
.PP
\&\s-1PARAMETERS:\s0
.IP "\(bu" 4
\&\f(CW\*(C`cmpBase\*(C'\fR \- Reference to array containing strings for base of
comparison.
.IP "\(bu" 4
\&\f(CW\*(C`minSim\*(C'\fR \- Minimal similarity you are prepared to accept. Specify a
value between 0 (not similar at all) and 1 (identity). Any string
matching with less (equals) than \f(CW\*(C`minSim\*(C'\fR will not be returned in
\&\f(CW\*(C`getSimilarStrings()\*(C'\fR and not counted as a match in \f(CW\*(C`getBestMatch()\*(C'\fR,
even if it is the only one. Default is 0, so anything even remotely
matching will be returned.
.IP "\(bu" 4
\&\f(CW\*(C`ngram\*(C'\fR \- If you do not want to use trigrams, but some other n in n\-gram, 
use this parameter, for example ngram => 5 for 5\-grams.
.IP "\(bu" 4
\&\f(CW\*(C`warp\*(C'\fR \- Set warp attribute (see description). Default is 1.0 (no warp).
.IP "\(bu" 4
\&\f(CW\*(C`ignoreCase\*(C'\fR \- Just that. Default is 1 (do ignore case)
.IP "\(bu" 4
\&\f(CW\*(C`keepOnlyAlNums\*(C'\fR \- Remove any \eW character before comparison. Default
is 0 (keep every character).
.IP "\(bu" 4
\&\f(CW\*(C`padding\*(C'\fR \- Set the number of blanks for padding string (see
above). The number has to be between 0 and n\-1 (n from n\-gram). Default is n\-1.
.IP "\(bu" 4
\&\f(CW\*(C`debug\*(C'\fR \- print some debugging information to \s-1STDERR\s0
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
it gets an unknown parameter
.IP "\(bu" 4
ngram is 0
.IP "\(bu" 4
parameter cmpBase does not point to a reference to an array
.IP "\(bu" 4
minimal similarity is out of bounds (should be 0 <= minSim <= 1)
.IP "\(bu" 4
warp is out of bounds (0 <= warp)
.IP "\(bu" 4
padding is out of bounds (should be 0 <= padding <= n\-1)
.SS "reInit"
.IX Subsection "reInit"
.Vb 1
\&  $trig\->reInit(["zebra", "tiger", "snake", "gorilla", "kangaroo"]);
.Ve
.PP
Give the object a new base of comparison (deleting the old one).
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
parameter does not point to a reference to an array
.SS "extendBase"
.IX Subsection "extendBase"
.Vb 1
\&  $trig\->extendBase(["zebra", "tiger", "snake", "gorilla", "kangaroo"]);
.Ve
.PP
Add strings to object's base of comparison.
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
parameter does not point to a reference to an array
.SS "minSim"
.IX Subsection "minSim"
.Vb 2
\&  $trig\->minSim();
\&  $trig\->minSim(0.8);
.Ve
.PP
Get or set minimal accepted similarity (see above).
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
minimal similarity is out of bounds (should be 0 <= minSim <= 1)
.SS "warp"
.IX Subsection "warp"
.Vb 2
\&  $trig\->warp();
\&  $trig\->warp(1.4);
.Ve
.PP
Get or set warp (see above).
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
warp is out of bounds (should be 0 <= warp)
.SS "ignoreCase"
.IX Subsection "ignoreCase"
.Vb 2
\&  $trig\->ignoreCase();
\&  $trig\->ignoreCase(0);
.Ve
.PP
Get or set ignoreCase property (see above).
.SS "keepOnlyAlNums"
.IX Subsection "keepOnlyAlNums"
.Vb 2
\&  $trig\->keepOnlyAlNums();
\&  $trig\->keepOnlyAlNums(1);
.Ve
.PP
Get or set keepOnlyAlNums property (see above).
.SS "padding"
.IX Subsection "padding"
.Vb 2
\&  $trig\->padding();
\&  $trig\->padding(2);
.Ve
.PP
Get or set padding property (see above).
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
padding is out of bounds (should be 0 <= padding <= n\-1)
.SS "debug"
.IX Subsection "debug"
.Vb 2
\&  $trig\->debug();
\&  $trig\->debug(1);
.Ve
.PP
Get or set debug property. For debugging to \s-1STDERR\s0, set to 1.
.SS "getSimilarStrings"
.IX Subsection "getSimilarStrings"
.Vb 2
\&  my %results = ();
\&  my $numOfSimStrings = $trig\->getSimilarStrings("zebrilla", \e%results [, minSim => 0.6, warp => 0.7]);
.Ve
.PP
Get similar strings for first parameter from base of comparison. The result is
saved in the second parameter (a reference to a hash), the keys being the strings
and the values the similarity values. The method returns the number of found
similar strings.
.PP
If parameters minSim or warp are defined, those values are changed temporalily.
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
second parameter is not a reference to a hash
.SS "getBestMatch"
.IX Subsection "getBestMatch"
.Vb 2
\&  my @bestMatches = ();
\&  my $sim = $trig\->getBestMatch("zebrilla", \e@bestMatches [, minSim => 0.6, warp => 0.7]);
.Ve
.PP
Don't bother about all those more or less similar strings, just get the best
one. This might actually be more than one, since several strings might result in
the same similarity value. So the second parameter is a reference to an array, taking the best similar strings,
the first parameter is the string to compare. Returns similarity of best match or 0 if there are no similar strings at all (please observe that in the case of no match the return value was \-1 up to \f(CW$VERSION\fR == 0.02).
.PP
If parameters minSim or warp are defined, those values are changed temporarily.
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.IP "\(bu" 4
second parameter is not a reference to an array
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "compare"
.IX Subsection "compare"
.Vb 1
\&  my $sim = compare($string1, $string2);
.Ve
.PP
or
.PP
.Vb 8
\&  my $sim = compare($string1,
\&                    $string2,
\&                    minSim         => 0.3,
\&                    warp           => 1.8,
\&                    ignoreCase     => 0,
\&                    keepOnlyAlNums => 1,
\&                    ngram          => 5,
\&                    debug          => 1);
.Ve
.PP
Use this if you don't want use the oo\- interface. Returns resulting similarity.
Note that this is not a very fast way to use the module, if you do a lot of 
comparisons, since internally for every call to \fIcompare()\fR a new Trigram object 
is initialized (and \f(CW\*(C`DESTROY\*(C'\fRed as it goes out of scope).
.PP
\&\s-1CROAKS\s0 \s-1IF\s0 ...
.PP
[same as using \fInew()\fR and \fIgetSimilarStrings()\fR]
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 1
\&  compare()
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Tarek Ahmed, <tarek@epost.de>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 Tarek Ahmed. All rights reserved. This program is free 
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\f(CW\*(C`String::Similarity\*(C'\fR \- Uses edit scripts to compute similarity between strings.
.IP "\(bu" 4
\&\f(CW\*(C`String::Approx\*(C'\fR \- Uses Levenshtein edit distance to compute similarity between strings.
.IP "\(bu" 4
\&\f(CW\*(C`Text::Soundex\*(C'\fR \- Uses soundex method to compute similarity between strings.
.PP
For an early description of the method, see:  R.C. Angell, G.E. Freund, and P. 
Willet. Automatic spelling correction using a trigram similarity measure. 
Information Processing and Management, 19(4):255\-\-261, 1983.
